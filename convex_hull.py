# -*- coding: utf-8 -*-
"""Convex Hull.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FRTJKJhTLmYaKeK-9DEbm2C6Y8I3mfn_

Autor: Baruc Samuel Cabrera García

# Implementar el algoritmo Graham Scan
La entrada debe ser un conjunto de puntos en 2D y la salida el conjunto de aristas que forman el CH ordenadas en sentido antihorario. Deberás tener alguna forma de desplegar la entrada y el resultado, ya sea de forma animada o estática. En esta tarea, poder desplegar el proceso de construcción no es obligatorio, pero dará puntos extra. Deberás entregar
- El código comentado en el lenguaje y con las librerías de visualización de tu elección.
- Un pequeño video demostrando y comentando la ejecución del programa en tu máquina.
"""

import numpy as np
import matplotlib.pyplot as plt

# Cantidad de puntos a considerar
n_puntos = 10

# Rango de las coordenadas de los puntos [0,10]
min, max = 0, 3

# Generar la lista de puntos en R^2
puntos = [np.random.uniform(min, max, size=(2,)) for _ in range(n_puntos)]

#Ordenamos con respecto a "x", y en caso de empate, respecto a "y"
puntos_ordenados = sorted(puntos, key=lambda x: (x[0], x[1]))

"""Recordemos que

    u x v = ||u||⋅||v||⋅sin(Θ)

Donde Θ es el angulo de u a v.

Usando lo anterior, podemos usar el producto cruz para determinar cuando un punto q se encuentra del lado izquierda del vector v-u, o en su caso, en el vector.
A continuación, se declararan las funciones necesarias para el código.
"""

#Funcion para imprimir el convex_hull, dados los puntos y las aristas.
#Se supone que Puntos ya esta ordenado
def Graficar(Puntos, convex_hull=None, final = False):
    xs, ys = zip(*Puntos)#Usamos zip para poder graficar todos los puntos a la vez
    plt.scatter(xs, ys, c='green')#Graficamos los puntos
    plt.scatter(Puntos[0][0], Puntos[0][1], c='red')#Destacamos el punto inicial

    if convex_hull != None:#Si ya hay aristas
        #Graficamos las aristas del convex hull
        for i in range(1, len(convex_hull)):
            #Uniremos los puntos i-1 y i
            c0 = convex_hull[i-1]
            c1 = convex_hull[i]
            plt.plot((c0[0], c1[0]), (c0[1], c1[1]), 'magenta')

        if final:#Bnadera para cerrar el convex hull
            c0 = convex_hull[-1]
            c1 = convex_hull[0]
            plt.plot((c0[0], c1[0]), (c0[1], c1[1]), 'magenta')
    plt.show()


#Hacemos una funcion que regrese el signo de (v-u)x(q-u)
# -1 -> Left
#  1 -> Right
#  0 -> On vector
def check_side(u,v,q):
  v1 = v-u
  v2 = q-u

  val = np.cross(v1 , v2)

  if val < 0:
    return 1
  elif val > 0:
    return -1
  return 0

#Se haran ajustes para que el convex hull se desarrolle en sentido antihorario
def Graham(puntos):#Recibe un arreglo de los puntos ya ordenados
  #Guardamos los puntos en orden invertido
  puntos_invertidos = puntos_ordenados.copy()  # Crear una copia para no modificar la lista original
  puntos_invertidos.reverse()

  #Control
  Graficar(puntos)

  n = len(puntos)

  #Realizamos el proceso de L_upper
  L_upper = []
  L_upper.append(puntos[0])
  L_upper.append(puntos[1])

  for i in range(2,n):
    L_upper.append(puntos[i])

    while len(L_upper) > 2:#Mientras hayan mas de 2 puntos
      Graficar(puntos,L_upper)#Control
      a = L_upper[-3]
      b = L_upper[-2]
      c = L_upper[-1]
      if check_side(a,c,b) != 1:#Si no se da una vuelta a la izquierda, o lo que es analogo, el punto b no esta a la derecha de ac
        L_upper.pop(-2)#Eliminamos al punto b
        Graficar(puntos,L_upper)#Control
      else:
        break

  #Realizamso el proceso de L_lower (Es analogo al proceso de L_upper, pero con los puntos en orden invertido)
  L_lower = []
  L_lower.append(puntos_invertidos[0])
  L_lower.append(puntos_invertidos[1])

  for i in range(2,n):
    L_lower.append(puntos_invertidos[i])

    while len(L_lower) > 2:#Mientras hayan mas de 2 puntos
      Graficar(puntos,L_upper+L_lower)#Control
      a = L_lower[-3]
      b = L_lower[-2]
      c = L_lower[-1]
      if check_side(a,c,b) != 1:#Si no se da una vuelta a la izquierda, o lo que es analogo, el punto b no esta a la derecha de ac
        L_lower.pop(-2)#Eliminamos al punto b
        Graficar(puntos,L_upper+L_lower)#Control
      else:
        break

  #Eliminamos el primer y ultimo punto de L_lower para eliminar repeticiones
  L_lower.pop(0)
  L_lower.pop(-1)
  Graficar(puntos,L_upper+L_lower,True)#Control final del Convex Hull
  return L_upper + L_lower

"""Como nota a parte, el desarrollo de L_upper y L_lower no es necesariamente sobre la parte superior o inferior del Convex Hull, es solo para determinar la primera mitad del convex hull y la última respectivamente.
La forma en que se envuelve, depende unicamente de la funcion check_side() y el if en el que se encuentre, para así considerar giras hacia la izquierda o derecha.

Ahora, mostraremos el resultado
"""

L = Graham(puntos_ordenados)

print("Las aristas del Convex Hull son")
for i in range(1,len(L)):
  print(f"{L[i-1]}\t{L[i]}")
  if i == len(L)-1:
    print(f"{L[i]}\t{L[0]}")